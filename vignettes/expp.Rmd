
<!--
%\VignetteEngine{knitr::docco_linear}
%\VignetteIndexEntry{An Introduction to expp}
-->


# Instructions for the usage of the package expp


**Supplement to "Spatial patterns of extra-pair paternity: beyond paternity gains and losses"**"

**For latest version see vignette('expp')**

## 1. Download R version R 3.0.2, for example from [cran.studio.com] (http://cran.rstudio.com/).

## 2. Open R, and install package expp from the repository "R-Forge", or copy the following line of code into your R console:  
`install.packages("expp", repos = 'http://rforge.net')`
  
## 3. Load package.
```{r, echo = FALSE, message=FALSE}
require(sp)
require(spdep)
require(Matrix)
require(rgeos)
require(deldir)
require(spatstat)
require(mgcv)
require(nlme)
require(abind)
require(tensor)
require(polyclip)
require(maptools)
```
  
```{r}
require(expp)
```

## 4. Load raw datasets
"Westerholz" is a mixed-deciduous oak forest close to Landsberg am Lech, Germany (48°08' N 10°53' E). The woodland of ca. 40 ha contains 277 nestboxes since 2007, which are used to investigate the breeding biology and the mating system of blue tits.

```{r}
data(westerholzBreeding)
data(westerholzEPP)

head(westerholzBreeding, 2)
head(westerholzEPP, 2)
```
  
## 5. Select individual years using `split()`
```{r}
b = split(westerholzBreeding, westerholzBreeding$year_)
e = split(westerholzEPP, westerholzEPP$year_) 
```

## 6. Prepare data
```{r, include = FALSE}
breedingDat = lapply(b, SpatialPointsBreeding, coords= ~x+y, id='id', breeding= ~male + female)
polygonsDat = lapply(breedingDat, DirichletPolygons)
eppDat    = lapply(e, eppMatrix, pairs = ~ male + female)
```
```{r, eval = FALSE}
breedingDat = lapply(b, SpatialPointsBreeding, coords= ~x+y, id='id', breeding= ~male + female)
polygonsDat = lapply(breedingDat, DirichletPolygons)
eppDat    = lapply(e, eppMatrix, pairs = ~ male + female)
```
  
## 7. The `epp()` function compiles an object of `class epp` from the input 'breedingDat', 'polygonsDat', and 'eppDat'. The `epp-object` contains the final datset and all input data, and can now be created.
```{r}
d = list()
for(i in 1 : length(breedingDat)) {
  d[[i]] = epp(breedingDat[[i]], polygonsDat[[i]], eppDat[[i]], rank = 3)
}
```
  
## 8. We can then plot the data of each year. The package supplies two different types of plots for `class epp` (output of function `epp()`  ).  
#### A. plot() will plot the study area, the territory borders, and the EPP (as red lines).
```{r fig.width=14, fig.height=12,  results = 'hide'}
plot(d[[1]])
```
#### B. barplot() will by default plot the number of EPP events for each breeding distance. 
```{r fig.width=7, fig.height=6}
barplot(d[[1]])
```
With the setting "relativeValues = TRUE" the proportion of EPP events within each breeding distance are plotted, and the proportion of available mates within each breeding distance is added as a dashed line. The maximal distance that is plotted depends on the setting of "rank" in step 7.
```{r fig.width=7, fig.height=6}
barplot(d[[1]], relativeValues = TRUE)
```


## 9. Combine data of the two years and clean data.
```{r}
dat = lapply(d, as.data.frame)
dat = do.call(rbind, dat)

names(dat)[which(names(dat) == 'year__FEMALE')] = 'year_'
dat$year__MALE <- NULL

head(dat)
```

## 10. We now have two data sets. "d" lists the output of the function epp() for the two years, including the input data. "dat" contains the combined data of the two seasons excluding the input data.
  
## 11. Since EPP is most frequent among direct neighbours, estimates for all other variable are most meaningful if they are assessed for direct neighbours. We therefore subtract '1' from the breeding distance, so that direct neighbours get scored as '0'. 
This transformation is important for the calculation of the intercept and if interactions are modelled.
```{r}
if(min(dat$rank == 1)) dat$rank = dat$rank - 1
```

## 12. As a next step, variables can be transformed to be relative to the surroundings of the males or the females. We here present breeding asynchrony as an example. 
Note that centering is performed within the respective surroundings whereas scaling is performed populationwide.
```{r}
center = function(x) { return(x - mean(x, na.rm = TRUE)) }
scale2 = function(x) { return(x/(2*sd(x, na.rm = TRUE))) }

#laying dates -> asynchrony
dat$asynchrony = abs(dat$layingDate_MALE - dat$layingDate_FEMALE)

#asynchrony -> relative asynchrony within the breeding distance of the focal pair
MALE_splitBy = paste(dat$year_, dat$id_MALE, dat$male, dat$rank, sep = "_")
dat$relative_asynchrony_MALE = unsplit(lapply(split(dat$asynchrony, MALE_splitBy), center), MALE_splitBy)
dat$relative_asynchrony_MALE = scale2(dat$relative_asynchrony_MALE)
  
FEMALE_splitBy = paste(dat$year_, dat$id_FEMALE, dat$female, dat$rank, sep = "_")
dat$relative_asynchrony_FEMALE = unsplit(lapply(split(dat$asynchrony, FEMALE_splitBy), center), FEMALE_splitBy)
dat$relative_asynchrony_FEMALE = scale2(dat$relative_asynchrony_FEMALE)
  
```

## 13. We can now make sure the sample size is sufficient for the number of variables we aim to include into the model.
```{r}
table(dat$epp, dat$year_) #sample size as the number of "0" and "1" in the epp column; "0" = no EPP; "1" = EPP;
```
  
## 14. And finally, we can run the model (this may take a while depending on your system!).
```{r, echo = (-1), message = FALSE}
require(lme4)
require(lme4)
  
fm = glmer(epp ~ rank + male_age_MALE + relative_asynchrony_MALE + relative_asynchrony_FEMALE + (1|male) + (1|female) + (1|year_), data = dat, family = binomial)
summary(fm)
```
  
## 15. Finally, you can plot the model output using for example the R package "effects".
```{r, echo=(-1), message = FALSE,  fig.width=10, fig.height=10}
require(effects)
require(effects)
plot(allEffects(fm))
```

