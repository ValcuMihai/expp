<!--
%\VignetteEngine{knitr::docco_linear}
%\VignetteIndexEntry{An introduction to expp}
-->


TODO check out other vignettes

An introduction to the _expp_ package
-------------------------------------

### Supplement to Schlicht, Valcu and Kempenaers _"Spatial patterns of extra-pair paternity: beyond paternity gains and losses"_ (in prep.)

**For latest version of this document type vignette('expp')**

#### 1. Get started
 * Download and install [R](http://cran.rstudio.com/).
 * Open R, and install _expp_ by copying the following line into your R console:  
```{r eval=FALSE }
install.packages("expp")
```  
  
```{r echo=FALSE, message=FALSE}
require(rgeos); require(sp); require(spdep); require(spatstat); require(deldir)
```
 * To load _expp_ type:   
```{r } 
require(expp)
```

#### 2. Load datasets
For info on the datasets type: 
```{r eval=FALSE }
help(westerholzBreeding)
help(westerholzEPP)
```
```{r}
data(westerholzBreeding)
data(westerholzEPP)
head(westerholzBreeding)
head(westerholzEPP)
```
  
#### 3. Prepare data

##### 3.1 Split by year

```{r}
b = split(westerholzBreeding, westerholzBreeding$year_)
e = split(westerholzEPP, westerholzEPP$year_) 

# sample sizes by year
lapply(b, nrow)
lapply(e, nrow)
```
##### 3.2 Run a couple of helper functions on both breeding data and extra-pair paternity data 
```{r}
breedingDat = lapply(b, SpatialPointsBreeding, coords= ~x+y, id='id', 
                     breeding= ~male + female)
eppDat = lapply(e, eppMatrix, pairs = ~ male + female)
```

##### 3.3. Compute Dirichlet polygons based on the `SpatialPointsBreeding` object
polygonsDat = lapply(breedingDat, DirichletPolygons)
  
  
#### 4. Now, all the objects are ready to be processed by the `epp` function.
Type `?epp` for more info and several examples on toy datasets.

```{r}
maxlag = 5
O = mapply(FUN = epp, breedingDat, polygonsDat, eppDat, maxlag)

plot(O[[1]]) # TODO: color EP individuals with red
title(main = 2009)

plot(O[[2]])
title(main = 2010)

# TODO: zoom in to a given area
# TODO: new method for Dirichlet polygons on a Spatial* object. use this method here!
# TODO: add zoom argument on plot(epp), zoom = x neighborhoods away, center = box no. for zoom.

op = par(mfrow = c(1,2))
barplot(O[[1]],relativeValues = TRUE, main = 2009) # todo add legend
barplot(O[[2]], relativeValues = TRUE, main = 2010)
par(op)

```
  
#### 5. In order to plug-in the data into a glmm we need to convert `O` (the output list) into a `data.frame`.
```{r}
dat = lapply(O, as.data.frame) # a list of data frames
dat = do.call(rbind, dat)
dat$year_ = dat$year__MALE; dat$year__FEMALE = NULL

```

#### 6. Data transformations prior to modelling.
Since EPP is most frequent among direct neighbours, estimates for all other variable are most meaningful if they are assessed for direct neighbours. We therefore substract '1' from the breeding distance, so that direct neighbours are set to '0'. This transformation is especially important if interactions are modeled.
```{r}
if(min(dat$rank == 1)) dat$rank = dat$rank - 1
```
Variables (e.g. breeding asynchrony ) can be transformed to be relative to the surroundings of the males or the females.
TODO: move transformations to O, before data

```{r}
center = function(x) { return(x - mean(x, na.rm = TRUE)) }
scale2 = function(x) { return(x/(2*sd(x, na.rm = TRUE))) }

#laying dates -> asynchrony
dat$asynchrony = abs(dat$layingDate_MALE - dat$layingDate_FEMALE)

#asynchrony -> relative asynchrony within the breeding distance of the focal pair
MALE_splitBy = paste(dat$year_, dat$id_MALE, dat$male, dat$rank, sep = "_")
dat$relative_asynchrony_MALE = unsplit(lapply(split(dat$asynchrony, MALE_splitBy), center), MALE_splitBy)
dat$relative_asynchrony_MALE = scale2(dat$relative_asynchrony_MALE)

FEMALE_splitBy = paste(dat$year_, dat$id_FEMALE, dat$female, dat$rank, sep = "_")
dat$relative_asynchrony_FEMALE = unsplit(lapply(split(dat$asynchrony, FEMALE_splitBy), center), FEMALE_splitBy)
dat$relative_asynchrony_FEMALE = scale2(dat$relative_asynchrony_FEMALE)
```

#### 7. Modelling
Check if sample size is sufficient for the number of variables we aim to include into the model.
```{r}
table(dat$epp, dat$year_) #sample size as the number of "0" and "1" in the epp column
```
Run the glmm model (this may take a while depending on your system!).
```{r eval=FALSE}
require(lme4)
dat$age2 = ifelse(dat$male_age_MALE == 'juv', 1, 2)
fm = glmer(epp ~ rank + male_age_MALE + relative_asynchrony_MALE + relative_asynchrony_FEMALE + (1|male) + (1|female) + (1|year_), data = dat, family = binomial)
summary(fm)
```











